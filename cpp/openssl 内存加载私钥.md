```c++
const char * const CLIENT_CERT =
        "Certificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number: 1 (0x1)\n    Signature Algorit"
        "hm: sha256WithRSAEncryption\n        Issuer: C=CN, ST=xxx, O=, CN=RootCA\n        Validity\n "
        "           Not Before: Sep 17 10:35:32 2019 GMT\n            Not After : Jan 18 10:35:32 3019 GMT\n   "
        "     Subject: C=CN, ST=xxx, O=xxx, CN=Client\n        Subject Public Key Info:\n            Pub"
        "lic Key Algorithm: rsaEncryption\n                Public-Key: (2048 bit)\n                Modulus:\n   "
        "                 00:e9:c1:fb:21:e9:ea:25:1a:11:b8:cb:45:97:b4:\n                    17:01:62:b3:74:49"
        ":66:4e:01:34:7e:53:bc:e3:4b:\n                    3e:c6:83:a7:6f:f2:c2:47:10:d0:99:4b:0c:99:32:\n     "
        "               92:c7:de:99:fa:58:02:0e:c0:de:6d:ce:b9:88:8c:\n                    39:99:36:04:ff:d7:1"
        "c:f7:51:4b:bf:c7:ff:81:d5:\n                    f7:a0:8e:41:da:bd:f3:fe:05:59:3c:cc:65:31:61:\n       "
        "             8c:36:66:3e:79:b7:64:f1:c8:5f:49:56:ca:74:f1:\n                    db:74:d5:04:51:4c:cf:"
        "9e:20:fc:5a:0a:b7:76:64:\n                    6b:25:08:cb:51:a3:bf:d4:57:89:fa:27:26:28:18:\n         "
        "           92:f6:92:ce:d4:0c:ea:93:50:f5:db:24:98:8e:bf:\n                    60:bb:37:24:fe:7d:68:d3"
        ":71:e2:e6:0e:5c:b7:43:\n                    4a:eb:70:08:27:ff:d3:c8:fb:81:00:96:11:ac:97:\n           "
        "         f6:33:8d:02:b3:05:ac:0c:9d:5e:2c:69:1a:99:ee:\n                    ea:c1:9e:22:d6:35:88:9b:8"
        "1:57:db:7c:e1:01:8b:\n                    5b:6e:2a:29:ae:9a:14:27:fb:14:0b:8b:67:bf:b0:\n             "
        "       e2:66:ad:d9:b7:95:9b:82:b0:e7:09:ce:f2:9a:be:\n                    95:61:e1:21:f8:b7:16:fa:55:"
        "70:29:50:55:ec:45:\n                    d3:15\n                Exponent: 65537 (0x10001)\n        X509v"
        "3 extensions:\n            X509v3 Basic Constraints: \n                CA:FALSE\n            X509v3 Key"
        " Usage: \n                Digital Signature, Non Repudiation, Key Encipherment\n    Signature Algorith"
        "m: sha256WithRSAEncryption\n         48:dc:e2:33:96:e9:21:0a:9e:a8:7c:fa:1d:b5:b5:19:94:fe:\n         "
        "65:63:77:1b:93:20:68:ea:13:e1:58:0d:b2:8c:ce:23:08:ed:\n         e9:b4:be:07:0c:b5:f8:99:ee:81:55:f2:"
        "e4:77:04:6d:b1:0e:\n         52:52:8c:8d:41:0b:d2:78:ac:76:b2:a8:58:61:77:64:18:39:\n         1d:00:05"
        ":f8:95:64:e1:30:db:05:d9:3a:6e:41:af:9f:bc:be:\n         f4:a2:da:c0:0f:ca:c9:6d:9a:cd:ce:b7:fd:e9:ad"
        ":34:15:00:\n         ce:e4:7f:23:c6:6f:40:c5:52:91:34:db:fd:8d:37:1e:ca:e9:\n         ed:9c:41:06:8f:e"
        "5:67:30:d1:77:2b:58:9c:44:e2:c4:83:6c:\n         c4:91:1f:65:d9:c6:27:17:dd:8c:3b:1b:db:e6:85:f7:73:e"
        "c:\n         9b:52:af:99:cb:10:86:91:e2:77:c1:7c:52:c7:19:16:6f:b7:\n         ff:3e:4d:ff:8b:5b:9f:d1:"
        "9e:a3:4e:68:a6:b3:e7:63:ff:6d:\n         a1:25:cb:1f:86:b0:97:2f:cf:07:14:1a:ad:be:bf:33:a8:09:\n     "
        "    43:97:6f:7e:9f:2f:47:a2:f9:d8:5f:7d:1d:d8:ec:fa:0c:ef:\n         f1:75:30:31:bb:76:2d:fd:ba:2a:72"
        ":63:bd:71:0f:f8:42:88:\n         60:ca:22:1d\n-----BEGIN CERTIFICATE-----\nMIIDGTCCAgGgAwIBAgIBATANBgkq"
        "hkiG9w0BAQsADBBMQswCQYDVQQGEwJDTjEP\nMA0GA1UECAwGeGlhbWVuMRAwDgYDVQQKDAdoYWl3ZWxsMQ8wDQYDVQQDDAZSb29"
        "0\nQ0EwIBcNMTkwTE3MTAzNTMyWhgPMzAxOTAxMTgxMDM1MzJaMEExCzAJBgNVBAYT\nAkNOMQ8wDQYDVQQIDAZ4aWFtZW4xEDAOB"
        "gNVBAoMB2hhaXdlbGwxDzANBgNVBAMM\nBkNsWVudDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOnB+yHp6iUa\nEbj"
        "LRZe0FwFis3RJZk4BNH5TvONLPsDp2/ywkcQ0JlLDJkyksfemfpYAg7A3m3O\nuYiMOZk2BP/XHPdRS7/H/4HV96COQdq98/4FWT"
        "zMZTFhjDZmPnm3ZPHIX0lWynTx\n23TVBFFMz54g/FoKt3kayUIy1Gjv9RXifonJigYkvaSztQM6pNQ9dskmI6/YLs3\nJP59aNNx"
        "4uYOXLdDSutwCCf/08j7gQCWEayX9jONArMFrAydXixpGpnu6sGeItY1\niJuBV9t84QGLW24qKa6aFCf7FAuLZ7+w4mat2beVm4K"
        "w5wnO8pq+lWHhIfi3FvpV\ncClQVexF0xUCAwEAAaMaMBgwCQYDVRTBAIwADALBgNVHQ8EBAMCBeAwDQYJKoZI\nhvcNAQELBQADg"
        "gEBAEjc4jOW6SEKnqh8+h21tRmU/mVjdxuTIGjqE+FYDbKMziMI\n7m0vgcMtfiZ7oFV8uR3BG2xDlJSjI1BC9J4rHayqFhhd2QY"
        "OR0ABfiVZOEw2wXZ\nOm5Br5+8vvSi2sAPysltms3Ot/3prTQVAM7kfyPGb0DFUpE02/2NNx7K6e2cQQaP\n5Wcw0XcrWJxE4sSDbM"
        "SRH2XZxicX3Yw7G9vmhfdz7JtSr5nLEIaR4nfBfFLHGRZv\nt/8+Tf+LW5/RnqNOaKaz52P/baElyx+GsJcvzwcUGq2+vzOoCUOXb"
        "36fL0ei+dhf\nfR3Y7PoM7/F1MDG7di39uipyY71xD/hCiGDKIh0=\n-----END CERTIFICATE-----\n";

const char * const CLIENT_PRIVATE_KEY =
        "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA6cH7IenqJRoRuMtFl7QXAWKzdElmTgE0flO840s+xoOnb/LC\nRxD"
        "QmUsMmTKSx96Z+lgCDsDebc65iIw5mTYE/9cc91FLv8f/gdX3oI5B2r3z/gVZ\nPxlMWGMNmY+ebdk8chfSVbKdPHbdNUEUUzPni"
        "D8Wgq3dmRrJQjLUaO/1FeJ+icm\nKBiS9pLO1zqk1D12ySYjr9guzck/n1o03Hi5g5ct0NK63AIJ//TyPuBAJYRrJf2\nM40CswWs"
        "DJ1eLGkame7qwZ4i1jWIm4FX23zhAYtbbioprpoUJ/sUC4tnv7DiZq3Z\nt5WbgrDnCc7ymr6VYeEh+LcW+lVwKVBV7EXTFQIDAQA"
        "BAoIBAQCzNP7VsiHKjeDW\nPig9NFiKvGNnCPtW2kmDAZ8bpxSzm3YGlEs8EwrqWigLjBvQE3lqgDx1JTxtBFz\nCKXDurE8fmr7g"
        "/zBq49Lt4DfOxBrpULgFLOkM8LEh9dZgSsWXy3pWscKT5po615m\nhESKG4vz26/7S8n43uVxf/t3vET9gSPp0sgJVpbuKCAeh951"
        "cxEZ+BdncLqgeOFy\nwK5hRmCxOA8eFeB+VoQCLWyQ3K5jtKzt1W0gYBTglNTvZmVTlZKMO9Hdmhw/BMWK\nLxogMmW99XOcOcn1g/"
        "z0fkBzxUgvZun2O88KthzuLYn3zTpXvPv3m9GdBVl2qBPM\n2gPTZ7clAoGBAPiMjkfOmdYf9CZCjeNNm+RVtQxsCPJLBKCejYNeR"
        "EH2ctDv3kFW\nxSafJEFAFq5uJQ9QyqKrNoge3v/pkeJWjjK7yGOSzj7hdDhmdMsOXdSXljQ3kW9\nHcGS+xykcP6vLeTYdy2jxvd"
        "oSYknKOR8APW+X2SVZoHCBPCIGeJRCeDAoGBAPDD\n6XnV0h1fv2I+4dCegSFAAxvRjhT1tIr4SLXx4qmgGlBU/xbGu7bBrXY5Ya"
        "OogOSW\n8h0+IbUZzKhT37kakUNvL7tLHmcazgV0SjtaOeuz5esnC01fVYkFrhN3mleDVRSc\nWATjyfSKSFigFV68sk2wYNx2p7qC"
        "0nOJKxZXaX+HAoGAVLWSyGZhh9jcHS4RraaF\nuwx66ADqC6oFqbhgAqXeHZ0hBJS76wjnqIIUmSh+knR3rQCcD1I5Vx4698fpo/f"
        "s\nB+8iEQ2uFXj3c0F4DLyYvhvr1WAa8RIn/C4JMrmtZ8fcJI3AU1ipzAcz4lcbnR\nme+IFYpKInTDC/jdkmv2DoECgYEA3Bfb6"
        "PpkF2IdzCv7tgAPv1uK+/U200ZBgwCx\nR1IViEbJh0IL5sBJfSnT7k1KSpeRLGYocj8IBUvOYNo7nDUDMggENEzZQBuq1iWW\nbmd"
        "up19PAQYyOMq7oITGuxkMyI9QSYUamW6goee1xWQM4h/3rEr+p2lesR4qhFs\niAHkeSUCgYBRyzzZn243nBNRSOQQirnaXOoLeO"
        "+40BHej8wNPU9WUSaRn0ug4Q5T\nEjvXRNSr3viLXGAdRs1Z+a8OAi7qxY/PGwaWSiMIsqWjiukvgLfVSUVCkhwEd8Wq\nd2cUMIfu"
        "uyAxfTbA83j7ZLs62m4YIuObXNxsV244KRVayplYnNg67Q==\n-----END RSA PRIVATE KEY-----\n";

class HttpsClient
{
public:

    HttpsClient();
    HttpsClient(const std::string &host, int port);

    ~HttpsClient();

    bool init();

    inline std::string lastError() const { return m_error; }
    inline std::string host()      const { return m_host; }
    inline int         port()      const { return m_port; }


    /**
     * 连接服务器。
     */
    bool tlsConnect();

    /**
     * 读取数据。
     */
    bool read(std::string &readDatas);

    /**
     * 写入数据。
     */
    bool write(const std::string &writeDatas);

    /**
     * 与服务器断开连接。
     */
    void tlsDisconnect();

private:

    /**
     * 关闭 socket 文件描述符。
     */
    void closeSocket();

    /**
     * 证书双向验证。
     */
    bool verify();

private:

    std::string m_host;
    int         m_port;
    std::string m_error;
    std::string m_cacertFile;
    std::string m_cacertPath;
    int         m_socketfd;
    SSL        *m_sslHandle;
    SSL_CTX    *m_sslContext;
};

HttpsClient::HttpsClient()
{
#if 0
    m_host = "192.168.70.5";
    m_port = 8087;
#else
    m_host = "x.x.x.x";
    m_port = 443;
#endif

    m_socketfd = -1;
    m_sslHandle = NULL;
    m_sslContext = NULL;

    m_cacertFile = GetPath().GetPrefixPath() + std::string("/config/root-cacert.pem");
    m_cacertPath = GetPath().GetPrefixPath() +  std::string("/config");
}

HttpsClient::HttpsClient(const std::string &host, int port)
{
    m_host = host;
    m_port = port;

    m_socketfd = -1;
    m_sslHandle = NULL;
    m_sslContext = NULL;

    m_cacertFile = GetPath().GetPrefixPath() + std::string("/config/root-cacert.pem");
    m_cacertPath = GetPath().GetPrefixPath() +  std::string("/config");
}

HttpsClient::~HttpsClient()
{
    SSL_CTX_free(m_sslContext);
    SSL_free(m_sslHandle);
}

bool HttpsClient::init()
{
    SSL_load_error_strings();
    SSL_library_init();
    OpenSSL_add_all_algorithms();

    m_sslContext = SSL_CTX_new(TLS_client_method());
    if (m_sslContext == NULL)
    {
        m_error = "[HttpsClient] SSL_CTX_new failed.";
        return false;
    }

    SSL_CTX_set_mode(m_sslContext, SSL_MODE_AUTO_RETRY);

    /** 启用 TLS1.2 */
    SSL_CTX_set_options(m_sslContext, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);

    // 去除双向认证
    if (verify() == false)
        return false;

    m_sslHandle = SSL_new(m_sslContext);
    if (m_sslHandle == NULL)
    {
        m_error = "[HttpsClient] SSL_new failed.";
        return false;
    }

    /** 创建一个普通的 socket 套接字 */
    m_socketfd = socket(AF_INET, SOCK_STREAM, 0);
    if (m_socketfd == -1)
    {
        m_error = "[HttpsClient] socket() failed.";
        return false;
    }

    /** 把普通套接字应用到 SSL 通信上 */
    if (!SSL_set_fd(m_sslHandle, m_socketfd))
    {
        m_error = "[HttpsClient] SSL_set_fd failed.";
        closeSocket();
        return false;
    }

    return true;
}

bool HttpsClient::tlsConnect()
{
#if 0
    struct sockaddr_in server;

    int rc, err;
    struct hostent host;
    struct hostent *result;
    char buf[10240];

    rc = gethostbyname_r(m_host.c_str(), &host, buf, sizeof(buf), &result, &err);

    if (rc != 0 || result == 0)
    {
        sleep(3);
        res_init();
        m_error = "[HttpsClient] gethostbyname_r failed.";
        return false;
    }

    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port = htons(m_port);
    server.sin_addr = *((struct in_addr *)host.h_addr);

    int error = connect(m_socketfd, (struct sockaddr *)&server, sizeof(struct sockaddr));
    if (error == -1)
    {
        m_error = "[HttpsClient] connect() failed.";
        return false;
    }
#endif

    struct addrinfo *result = NULL,
                     hints;

    memset(&hints, 0 , sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    int ret = getaddrinfo(m_host.c_str(), Int_To_String(m_port).c_str(), &hints, &result);
    if (ret)
    {
        sleep(3);
        res_init();
        m_error = "[HttpsClient] getaddrinfo failed.";
        return false;
    }

    ret = connect(m_socketfd, result->ai_addr, result->ai_addrlen);
    if (ret == -1)
    {
        freeaddrinfo(result);
        m_error = "[HttpsClient] connect() failed.";
        return false;
    }

    freeaddrinfo(result);

    if (SSL_connect(m_sslHandle) != 1)
    {
        m_error = "[HttpsClient] SSL_connect failed.";
        return false;
    }

    return true;
}

bool HttpsClient::read(string &readDatas)
{
    char data[1024];

    /** 读取头部 */
    memset(data, 0, sizeof(data));
    SSL_read(m_sslHandle, data, sizeof(data) - 1);

    //readDatas = data;

    /** 获取 body 长度 */
    char* contentLengthIndex = strstr(data, "Content-Length:");
    int nread = 0;
    if (contentLengthIndex)
    {
        nread = atoi(contentLengthIndex + strlen("Content-Length:"));

        char *bodyIndex = strstr(contentLengthIndex, "\r\n\r\n");
        if (bodyIndex)
        {
            bodyIndex = bodyIndex + strlen("\r\n\r\n");
            readDatas += bodyIndex;
            nread -= readDatas.size();
            if (nread < 0)
            {
                debug("[HttpsClient] SSL_read redundant datas byyond expected.\n");
                return false;
            }
        }
    }
    else
    {
        m_error = "[HttpsClient] SSL_read can't get http response Content-Length.";
        return false;
    }

    int remaining = nread;
    while (remaining)
    {
        memset(data, 0, sizeof(data));
        int readed = SSL_read(m_sslHandle, data, sizeof(data));

        if (readed < 0)
        {
            m_error = "[HttpsClient] SSL_read failed.";
            return false;
        }
        else if (readed > 0)
            readDatas += data;

        remaining -= readed;
    }

    return true;
}

bool HttpsClient::write(const string &writeDatas)
{
    const char *data = writeDatas.c_str();
    int nbytes = writeDatas.size();
    int writed;
    int remaining = nbytes;

    while (remaining)
    {
        writed = SSL_write(m_sslHandle, data + (nbytes - remaining), remaining);

        if (writed <= 0)
        {
            m_error = "[HttpsClient] SSL_write failed.";
            return false;
        }

        remaining -= writed;
    }

    return true;
}

void HttpsClient::tlsDisconnect()
{
    closeSocket();
    SSL_shutdown(m_sslHandle);
}

void HttpsClient::closeSocket()
{
    close(m_socketfd);
    m_socketfd = -1;
}

bool HttpsClient::verify()
{
    /** 加载服务端证书 */
    int ret = SSL_CTX_load_verify_locations(m_sslContext, m_cacertFile.c_str(), m_cacertPath.c_str());
    if (ret == 0)
    {
        m_error = "[HttpsClient] SSL_CTX_load_verify_locations failed.";
        return false;
    }

    // 这个地方写 SSL_VERIFY_NONE 可能有问题，见 https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_verify.html
    SSL_CTX_set_verify(m_sslContext, SSL_VERIFY_NONE, NULL);

    /** 从内存中加载客户端证书 */
    BIO *certBIO = BIO_new_mem_buf((void*)CLIENT_CERT, -1);
    if (certBIO == NULL)
    {
        m_error = "[HttpsClient] BIO_new_mem_buf(CLIENT_CERT) return NULL";
    }
    X509 *certX509 = PEM_read_bio_X509(certBIO, NULL, 0, NULL);
    if (certX509 == NULL)
    {
        m_error = "[HttpsClient] PEM_read_bio_X509 return NULL";
    }
    ret = SSL_CTX_use_certificate(m_sslContext, certX509);

    /** 析构 */
    BIO_set_close(certBIO, BIO_NOCLOSE);
    BIO_free(certBIO);
    X509_free(certX509);

    if (ret != 1)
    {
        m_error = "[HttpsClient] SSL_CTX_use_certificate failed.";
        return false;
    }

    /** 从内存中加载客户端私钥 */
    BIO *keyBIO = BIO_new_mem_buf((void*)CLIENT_PRIVATE_KEY, -1);
    if (keyBIO == NULL)
    {
        m_error = "[HttpsClient] BIO_new_mem_buf(CLIENT_PRIVATE_KEY) return NULL";
    }
    RSA *keyRSA = PEM_read_bio_RSAPrivateKey(keyBIO, NULL, 0, NULL);
    if (keyRSA == NULL)
    {
        m_error = "[HttpsClient] PEM_read_bio_RSAPrivateKey return NULL";
    }
    ret = SSL_CTX_use_RSAPrivateKey(m_sslContext, keyRSA);

    /** 析构 */
    BIO_set_close(keyBIO, BIO_NOCLOSE);
    BIO_free(keyBIO);
    RSA_free(keyRSA);

    if (ret != 1)
    {
        m_error = "[HttpsClient] SSL_CTX_use_RSAPrivateKey failed.";
        return false;
    }

    /** 验证客户端证书和私钥 */
    ret = SSL_CTX_check_private_key(m_sslContext);
    if (ret != 1)
    {
        m_error = "[HttpsClient] SSL_CTX_check_private_key failed.";
        return false;
    }

    return true;
}
```
