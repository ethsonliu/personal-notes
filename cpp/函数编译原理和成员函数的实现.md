C++ 和 C 的编译原理不同，C 中的函数在编译时名字不变，或者简单的加一个 _ （不同的编译器编译方式不同）。而 C++ 中的函数在编译时会根据它所在的命名空间、所属的类以及参数列表等信息进行重
命名，形成一个新的函数名。这个函数名只有编译器知道，用户是不可见的，对函数重命名的过程叫做名字编码。这样就保证了即使是函数的重载，根据参数列表的不同也能编译出不同的名字。

成员函数最终会被编译成与对象无关的全局函数，如果函数中没有成员变量，那问题就很简单了，不用对函数做任何处理，直接调用就行。

如果成员函数中使用了成员变量，而成员变量不是全局的，不经过处理就无法在函数内部访问。因此，C++ 规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针对象的指针来访问
成员变量。

假设 Test 类有两个 int 型的成员变量 a、b,并且在成员函数 show() 中使用，如下所示：

```
void Test::show()
{
		cout <<a <<endl;
		cout <<b <<endl;
}
```

那么编译后的代码类适于：

```
void new_function_name(Test *const p)
{
		cout << p->a <<endl;
		cout << p->b <<endl;
}
```

使用对象调用成员函数时 obj.show()，

```
new_function_name(&obk);
```

这样通过传递对象的指针就完成了成员函数和成员变量的关联。这与我们所看到的现象刚好相反，通过对象调用成员函数时，不是通过对象找函数，而是通过函数找对象。

这些都是由编译器完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。
