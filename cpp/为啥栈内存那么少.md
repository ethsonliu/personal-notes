

栈让你分配和释放简单化，但是他有一个重大缺点：释放的次序是固定的，必须是分配次序的反序。

假设栈上对象分配次序是 ABCDEF。 可能在某些情况时，我释放 F 的时候，A 可以释放了但其他对象都不能释放；某些情况时我释放 F 的时候，B 可以释放了但其他对象都不能释放.... 对不起，这些栈上对象
都不能提前释放：ABCD 必须等待 F 和 E 释放了之后才能释放。

换而言之，栈的分配和释放非常迅速（一个函数内栈的分配和回收 各自只需要一条指令），但是释放非常不灵活，极易造成浪费。越是复杂的程序，函数调用栈越深的情况，你将越会频繁的遇到这种函数 A call
函数 B，B 知道 A 的某个局部变量可以提前回收内存了但是却无能为力除非 B 返回的场景。所以，操作系统 api 都会限制栈的最大大小来让你浪费有个上限度，并且提供了“堆”。事实上，在栈出来之前，
所有的内存都是堆，所有的内存都是供程序员自由的分配和释放。然而堆的管理显然复杂的多，因为栈的已分配和未分配内存各自是连续的一块，堆却是很多块已分配和未分配的内存混杂在一起，需要程序员
去在这些内存块里标记他们的长度，分配时选择或者分割一个合适的块，回收时合理的进行合并。所以高级语言出来把栈和堆分开之后，第一件事就是得封装堆，glibc 就是干这事。
